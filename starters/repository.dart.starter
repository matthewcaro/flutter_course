import 'dart:io';
import 'dart:convert';
import 'package:http/http.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:intl/intl.dart';
import 'film.dart';

/// Returns the best URL string based on the running platform. 
/// The different platforms block different URLs. This function 
/// allows us to request API data regardless of where we're 
/// debugging.
String getBaseUrl({String port = "3008"}) {
  // android 10.0.2.2 via AVD
  // android 10.0.3.2 via Genymotion
  // iOS via iPhone Simulator http://localhost:$port
  // web
  //String baseUrl = "http://127.0.0.1:$port";
  String baseUrl = "http://localhost:$port";
  if (kIsWeb) {
    return baseUrl; // Must be first b/c Platform.operatingSystem throws on web.
  }
  if (Platform.isMacOS) return "http://localhost:$port";
  if (Platform.isAndroid) {
    return "http://10.0.2.2:$port";
  } else {
    return baseUrl;
  }
}

// Fetch films using a strongly-typed class
Future<List<Film>> fetchFilms() {
  String url = '${getBaseUrl()}/api/films';
  return get(Uri.parse(url)).then((res) {
    List<dynamic> films = jsonDecode(res.body);
    return films
        .map((f) => Film()
          ..id = f['id']
          ..homepage = f['homepage']
          ..imdbId = f['imdb_id']
          ..overview = f['overview']
          ..popularity = f['popularity']
          ..posterPath = f['poster_path']
          ..releaseDate = DateTime.parse(f['release_date'])
          ..runtime = f['runtime']
          ..tagline = f['tagline']
          ..title = f['title']
          ..voteAverage = f['vote_average']
          ..voteCount = f['vote_count'])
        .toList();
  }).catchError((err) {
    print("Problem fetching films!");
    print(err);
    return <Film>[];
  });
}

// Fetch showings using a dynamic List
Future<List<dynamic>> fetchShowings(
    {required int filmId, required DateTime date}) {
  String url =
      "${getBaseUrl()}/api/showings/$filmId/${DateFormat('yyyy-MM-dd').format(date)}";
  return get(Uri.parse(url)).then((res) => jsonDecode(res.body));
}

/***********************************************************************
SuperState included below for convenience in copying
***********************************************************************/
import 'package:flutter/material.dart';

/// The root class.
class SuperState<T> extends StatefulWidget {
  SuperState({
    super.key,
    required this.initialState,
    required this.child,
  }) : stateWrapper = StateWrapper<T>(state: initialState);

  final T initialState;
  final StateWrapper<T> stateWrapper;
  final Widget child;

  /// Gets a copy of the user's state object.
  static SuperStateState of(BuildContext context) {
    return context
        .dependOnInheritedWidgetOfExactType<_SuperStateInheritedWidget>()!
        .stateWidget;
  }

  @override
  State<SuperState> createState() => SuperStateState();
}

/// Allows the user to mutate data and see the rerendered results.
class SuperStateState<T> extends State<SuperState> {
  late StateWrapper<T> appState;

  @override
  void initState() {
    appState = widget.stateWrapper as StateWrapper<T>;
    super.initState();
  }

  void change(T newState) {
    setState(() {
      appState = StateWrapper<T>(state: newState);
    });
  }

  @override
  Widget build(BuildContext context) {
    return _SuperStateInheritedWidget(
      stateWidget: this,
      state: appState,
      child: widget.child,
    );
  }
}

/// Hidden. User never sees this.
class _SuperStateInheritedWidget extends InheritedWidget {
  const _SuperStateInheritedWidget({
    required this.stateWidget,
    required this.state,
    required super.child,
  });

  final SuperStateState stateWidget;
  final StateWrapper state;

  @override
  bool updateShouldNotify(_SuperStateInheritedWidget oldWidget) {
    return state != oldWidget.state;
  }
}

/// Holds a user-defined object<T> called state, which is the state of the app
@immutable
class StateWrapper<T> {
  const StateWrapper({required this.state});

  final T state;
}
